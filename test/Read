Integration Testing
My primary focus in integration testing was to ensure that all requirements were tested.
At the beginning of the project, I had a clear divide between the UI and all of the backend. This meant that Victorio, who worked on the user interface in JavaFX, was in frequent contact with the other team members to communicate which parameters his methods needed to receive.
I put the two components together early on as I didn't want to run into unexpected errors too late in the project.
The first integration testing occurred on the login system. By trying to login different users (existing and non-existing) and ensuring they were correctly stored in the SQLite Database, I verified that a user was able to login to the main menu of the game. What I realized during this stage, however, was that I had missed some of the password criterion required. Upon making this realization, I implemented a more strict account creation process. I also improved our error messages for incorrect login attempts at this stage.
Testing the UI comprised of clicking all the buttons and making sure that they all did what they were supposed to. The issue I ran into was that some of my backend was behind schedule which resulted in inconsistencies on the frontend (especially concerning gameplay buttons).
After setting up the main menu, I proceeded to test gameplay. There were a few small hitches, like two users starting in the same cell, but I got around these problems fairly easily. Another issue encountered through repeated trials of the system was that the heads of the racers could cross without the detection of a collision as shown below. I made sure to test gameplay with maps once they were implemented just to confirm that a user would not be able to drive through the obstacle.

The final major component to test was the statistics system. The test data for this was provided by the professor as input for our final class demo. Although very late due to delays in setting up the database and connecting queries to the UI, I managed to perform these tests successfully with no unexpected errors popping up.
One final note that I would address if there were more time would be to improve the timing of certain actions occurring in the UI. As it stands, the round and game scores update when a user closes the “Next Round” screen, but ideally these actions would occur simultaneously. Also, I couldn’t figure out how to get the cursor positioned on the text-boxes up-front which requires a player to either “Tab” to get the box in focus or to click on the button as opposed to hitting “Enter” or “Space”.
Overall, integration testing went smoothly due to a well thought-out software architecture with relatively loose coupling between packages.
